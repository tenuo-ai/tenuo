# Tenuo LangChain Integration

> **Status**: ✅ Implemented  
> **Location**: `tenuo-python/examples/`

## Overview

Tenuo integrates with LangChain using a **zero-intrusion** pattern:

1. Tools remain pure business logic—no security imports
2. Security is applied at composition time via decorators
3. Warrants are passed through context, not function arguments
4. Fail-closed: missing or invalid warrants block execution

---

## Installation
```bash
pip install tenuo
```

---

## Quick Start
```python
from tenuo import Keypair, Warrant, Pattern, lockdown, set_warrant_context

# 1. Define a protected tool
@lockdown(tool="read_file")
def read_file(file_path: str) -> str:
    """Pure business logic—no security code"""
    with open(file_path, 'r') as f:
        return f.read()

# 2. Create keypair and warrant
keypair = Keypair.generate()
warrant = Warrant.create(
    tool="read_file",
    constraints={"file_path": Pattern("/tmp/*")},
    ttl_seconds=3600,
    keypair=keypair
)

# 3. Execute with warrant context
with set_warrant_context(warrant):
    content = read_file("/tmp/test.txt")  # ✅ Authorized
    content = read_file("/etc/passwd")    # ❌ Blocked by constraint
```

---

## Connecting to CLI-Generated Keys

Use keys generated by `tenuo keygen`:
```python
from tenuo import Keypair

# 1. Generate keys using CLI
# $ tenuo keygen --out agent.key

# 2. Load raw bytes in Python
with open("agent.key", "rb") as f:
    secret_bytes = f.read()

keypair = Keypair.from_bytes(secret_bytes)
```

Warrants issued by the CLI can be loaded:
```python
from tenuo import Warrant

# Load base64 warrant from CLI output
warrant = Warrant.from_base64(cli_warrant_string)
```

---

## The `@lockdown` Decorator
```python
@lockdown(
    tool="read_file",
    extract_args=lambda file_path, **kwargs: {"file_path": file_path}
)
def read_file(file_path: str) -> str:
    ...
```

**Parameters:**

| Parameter | Description |
|-----------|-------------|
| `tool` | Tool name to check against warrant (required) |
| `extract_args` | Function to extract constraint-relevant args (optional) |

**Behavior:**

1. Retrieves current warrant from context
2. Verifies tool is in warrant's allowed tools
3. Verifies extracted args satisfy warrant constraints
4. Generates PoP signature using context keypair
5. Executes function if authorized, raises `AuthorizationError` if not

---

## Context Management

### `set_warrant_context`

Sets the active warrant and keypair for the current execution context.
```python
with set_warrant_context(warrant):
    # All @lockdown calls use this warrant
    protected_function()
```

**Parameters:**

| Parameter | Description |
|-----------|-------------|
| `warrant` | Active warrant for authorization |

**Properties:**

- Thread-safe (uses `contextvars`)
- Async-safe
- Nestable (inner context shadows outer)

---

## LangChain Agent Example
```python
from langchain.tools import Tool
from langchain.agents import AgentExecutor, create_openai_tools_agent
from langchain_openai import ChatOpenAI
from tenuo import Keypair, Warrant, Pattern, lockdown, set_warrant_context

# Protected tools
@lockdown(tool="search")
def search(query: str) -> str:
    return f"Results for: {query}"

@lockdown(tool="read_file", extract_args=lambda path, **kw: {"file_path": path})
def read_file(path: str) -> str:
    with open(path) as f:
        return f.read()

# Warrant setup
keypair = Keypair.generate()
warrant = Warrant.create(
    tool="read_file",
    constraints={"file_path": Pattern("/tmp/*")},
    ttl_seconds=3600,
    keypair=keypair
)

# LangChain setup
tools = [
    Tool(name="search", func=search, description="Search the web"),
    Tool(name="read_file", func=read_file, description="Read a file"),
]
llm = ChatOpenAI(model="gpt-4")
agent = create_openai_tools_agent(llm, tools)
executor = AgentExecutor(agent=agent, tools=tools)

# Run with protection
with set_warrant_context(warrant):
    response = executor.invoke({"input": "Search for Q3 results"})
```

---

## Error Handling
```python
from tenuo import AuthorizationError

try:
    with set_warrant_context(warrant):
        read_file("/etc/passwd")
except AuthorizationError as e:
    print(f"Authorization failed: {e}")
```

---

## Constraints

Constraints restrict tool arguments. They mirror CLI constraint types:

| Type | Python | CLI Equivalent |
|------|--------|----------------|
| Exact | `Exact("/etc/hosts")` | `path=exact:/etc/hosts` |
| Pattern | `Pattern("/tmp/*")` | `path=pattern:/tmp/*` |
| Regex | `Regex(r"^prod-.*")` | `name=regex:^prod-.*` |
| Range | `Range(min=0.8, max=1.0)` | `confidence=range:0.8..1.0` |
| OneOf | `OneOf(["active", "pending"])` | `status=oneof:active,pending` |

---

## Examples

- **Simple**: `tenuo-python/examples/langchain_simple.py` - Basic integration
- **Advanced**: `tenuo-python/examples/langchain_integration.py` - With callbacks

---

## Limitations

- **Manual wrapping**: You must apply `@lockdown` to each tool
- **Manual attenuation**: Delegation requires explicit warrant creation
- **Single warrant**: Context holds one warrant at a time

For automatic attenuation in multi-agent graphs, see [langgraph-spec.md](./langgraph-spec.md).

---

## See Also

- [CLI Reference](./cli-spec.md)
- [Python API Reference](./api-reference.md)
- [LangGraph Design](./langgraph-spec.md) (future)
- [Core Specification](./spec.md)
