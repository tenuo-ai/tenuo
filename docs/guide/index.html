<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tenuo Docs</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #0a0a0a;
            --surface: #141414;
            --border: #262626;
            --text: #fafafa;
            --muted: #a1a1a1;
            --accent: #00d4ff;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.7;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 56px;
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(8px);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .header-logo {
            font-weight: 700;
            font-size: 1.25rem;
            letter-spacing: -0.5px;
        }

        .header-logo a {
            color: var(--text);
            text-decoration: none;
        }

        .layout {
            display: flex;
            min-height: 100vh;
            padding-top: 56px;
        }

        /* Sidebar */
        .sidebar {
            width: 240px;
            border-right: 1px solid var(--border);
            padding: 24px 16px;
            position: fixed;
            top: 56px;
            bottom: 0;
            overflow-y: auto;
        }

        .sidebar-section {
            margin-bottom: 8px;
        }

        .sidebar-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--muted);
            padding: 8px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-radius: 6px;
            transition: all 0.15s;
            user-select: none;
        }

        .sidebar-title:hover {
            background: var(--surface);
            color: var(--text);
        }

        .sidebar-title::after {
            content: '+';
            font-size: 1rem;
            font-weight: 300;
            opacity: 0.5;
        }

        .sidebar-section.expanded .sidebar-title::after {
            content: '−';
        }

        .sidebar-links {
            overflow: hidden;
            max-height: 0;
            transition: max-height 0.25s ease;
        }

        .sidebar-section.expanded .sidebar-links {
            max-height: 500px;
        }

        .sidebar-link {
            display: block;
            padding: 6px 12px 6px 20px;
            margin: 2px 0;
            border-radius: 6px;
            color: var(--muted);
            text-decoration: none;
            font-size: 0.85rem;
            transition: all 0.15s;
        }

        .sidebar-link:hover {
            background: var(--surface);
            color: var(--text);
        }

        .sidebar-link.active {
            background: var(--surface);
            color: var(--accent);
        }

        /* Main content */
        .main {
            flex: 1;
            margin-left: 240px;
            padding: 40px 64px 80px;
            max-width: 800px;
        }

        h1 {
            font-size: 2rem;
            font-weight: 600;
            margin-bottom: 16px;
        }

        h2 {
            font-size: 1.4rem;
            font-weight: 600;
            margin: 48px 0 16px;
            padding-top: 24px;
            border-top: 1px solid var(--border);
        }

        h3 {
            font-size: 1.1rem;
            font-weight: 600;
            margin: 32px 0 12px;
        }

        p {
            color: var(--muted);
            margin-bottom: 16px;
        }

        p strong { color: var(--text); }

        code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85em;
            background: var(--surface);
            padding: 2px 6px;
            border-radius: 4px;
        }

        pre {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            overflow-x: auto;
            margin: 16px 0;
        }

        pre code {
            background: none;
            padding: 0;
        }

        .tip {
            background: rgba(0, 212, 255, 0.1);
            border-left: 3px solid var(--accent);
            padding: 12px 16px;
            margin: 16px 0;
            border-radius: 0 8px 8px 0;
        }

        .tip p { margin: 0; color: var(--text); }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 16px 0;
            font-size: 0.9rem;
        }

        th, td {
            text-align: left;
            padding: 12px;
            border-bottom: 1px solid var(--border);
        }

        th { color: var(--text); font-weight: 500; }
        td { color: var(--muted); }

        a { color: var(--accent); text-decoration: none; }
        a:hover { text-decoration: underline; }

        ul, ol {
            margin: 16px 0;
            padding-left: 24px;
            color: var(--muted);
        }

        li { margin: 8px 0; }
        li strong { color: var(--text); }

        @media (max-width: 900px) {
            .sidebar { display: none; }
            .main { margin-left: 0; padding: 24px 20px 60px; }
        }

        /* Scroll offset for fixed header */
        h1[id], h2[id], h3[id] {
            scroll-margin-top: 80px;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-logo"><a href="../">tenuo</a></div>
    </header>

    <div class="layout">
        <aside class="sidebar">
            <div class="sidebar-section">
                <div class="sidebar-title">Getting Started</div>
                <div class="sidebar-links">
                    <a href="#introduction" class="sidebar-link">Introduction</a>
                    <a href="#quick-start" class="sidebar-link">Quick Start</a>
                    <a href="#demo" class="sidebar-link">Demo</a>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title">Concepts</div>
                <div class="sidebar-links">
                    <a href="#warrants" class="sidebar-link">Warrants</a>
                    <a href="#attenuation" class="sidebar-link">Attenuation</a>
                    <a href="#constraints" class="sidebar-link">Constraints</a>
                    <a href="#holder-binding" class="sidebar-link">Holder Binding</a>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title">Approvals</div>
                <div class="sidebar-links">
                    <a href="#multi-sig" class="sidebar-link">Multi-Sig</a>
                    <a href="#notary" class="sidebar-link">Notary Registry</a>
                    <a href="#approval-flow" class="sidebar-link">Approval Flow</a>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title">Verification</div>
                <div class="sidebar-links">
                    <a href="#chain-verification" class="sidebar-link">Chain Verification</a>
                    <a href="#revocation" class="sidebar-link">Revocation</a>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title">Architecture</div>
                <div class="sidebar-links">
                    <a href="#planes" class="sidebar-link">Control vs Data Plane</a>
                    <a href="#properties" class="sidebar-link">Security Properties</a>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title">Reference</div>
                <div class="sidebar-links">
                    <a href="https://github.com/tenuo/tenuo/blob/main/README.md" class="sidebar-link">README</a>
                    <a href="https://docs.rs/tenuo-core" class="sidebar-link">API Docs ↗</a>
                </div>
            </div>
        </aside>

        <main class="main">
            <h1 id="introduction">Introduction</h1>
            <p>
                Tenuo is a capability-based authorization library for AI agent workflows.
                It uses signed tokens called <strong>warrants</strong> to control what actions agents can perform.
            </p>
            <p>
                The core invariant: when a warrant is delegated, its capabilities can only <strong>shrink</strong>.
                A $1000 budget becomes $500. Access to <code>staging-*</code> narrows to <code>staging-web</code>.
            </p>
            <p>
                Verification is local (no network calls required). Typical latency is ~25μs.
            </p>

            <h3>Where Tenuo Fits</h3>
            <p>
                Tenuo operates <strong>above</strong> your infrastructure's IAM layer. It doesn't replace it.
            </p>
            <pre><code>┌─────────────────────────────────────────────────────────┐
│  Agent Request                                          │
│  "I want to restart staging-web"                        │
└───────────────────────┬─────────────────────────────────┘
                        ▼
┌─────────────────────────────────────────────────────────┐
│  Tenuo Layer (Application)                              │
│  ✓ Does this warrant allow "restart" on "staging-web"?  │
│  ✓ Is the delegation chain valid?                       │
│  ✓ Is the holder's signature correct?                   │
└───────────────────────┬─────────────────────────────────┘
                        ▼
┌─────────────────────────────────────────────────────────┐
│  Infrastructure IAM (AWS IAM / K8s RBAC / etc.)         │
│  ✓ Does this service account have permission?           │
│  ✓ Is the network policy satisfied?                     │
└─────────────────────────────────────────────────────────┘</code></pre>
            <p>
                Your microservices still use their existing IAM (AWS roles, Kubernetes service accounts, etc.).
                Tenuo adds a <strong>delegation layer</strong> that tracks <em>why</em> an agent is acting and 
                <em>what limits</em> apply to that specific task. Infrastructure IAM can't express this.
            </p>
            <div class="tip">
                <p>Think of it this way: IAM answers "can this service call this API?" 
                Tenuo answers "who delegated this authority, what task context does it carry, and is this action within those bounds?"</p>
            </div>
            <p>
                Warrants carry context through the delegation chain. A constraint like 
                <code>order_status == 'approved'</code> ties an agent's capabilities to 
                actions performed earlier in the workflow. The <code>session_id</code> binds 
                the entire chain to a specific task.
            </p>

            <h2 id="quick-start">Quick Start</h2>
            <p>Add to your Rust project:</p>
            <pre><code>[dependencies]
tenuo-core = "0.1"</code></pre>

            <p><strong>1. Create a warrant</strong></p>
            <pre><code>use tenuo_core::{Keypair, Warrant, Pattern, Range};
use std::time::Duration;

let keypair = Keypair::generate();
let warrant = Warrant::builder()
    .tool("manage_infrastructure")
    .constraint("cluster", Pattern::new("staging-*")?)
    .constraint("budget", Range::max(1000.0))
    .ttl(Duration::from_secs(3600))
    .build(&keypair)?;</code></pre>

            <p><strong>2. Attenuate and delegate</strong></p>
            <pre><code>let worker_keypair = Keypair::generate();
let worker_warrant = warrant.attenuate()
    .constraint("cluster", Exact::new("staging-web"))
    .constraint("budget", Range::max(100.0))
    .authorized_holder(worker_keypair.public_key())
    .build(&keypair)?;</code></pre>

            <p><strong>3. Verify and authorize</strong></p>
            <pre><code>use tenuo_core::Authorizer;

let authorizer = Authorizer::new(keypair.public_key());
let chain = vec![warrant, worker_warrant];

// Worker signs the request (Proof-of-Possession)
let sig = worker_warrant.create_pop_signature(
    "manage_infrastructure", &args, &worker_keypair
);

authorizer.authorize(&chain, "manage_infrastructure", &args, Some(&sig), &[])?;</code></pre>

            <h2 id="demo">Demo</h2>
            <p>
                See the full flow in action with Docker:
            </p>
            <pre><code>docker compose up orchestrator worker</code></pre>
            <p>
                <a href="../demo-infographic.html">View the interactive infographic →</a>
            </p>

            <h2 id="warrants">Warrants</h2>
            <p>
                A <strong>warrant</strong> is a signed token that authorizes a specific action with specific constraints.
                Every warrant contains:
            </p>
            <table>
                <tr><th>Field</th><th>Description</th></tr>
                <tr><td><code>id</code></td><td>Unique identifier (UUIDv7)</td></tr>
                <tr><td><code>tool</code></td><td>What action is authorized</td></tr>
                <tr><td><code>constraints</code></td><td>Restrictions on arguments</td></tr>
                <tr><td><code>expires_at</code></td><td>When the warrant expires</td></tr>
                <tr><td><code>issuer</code></td><td>Who signed this warrant</td></tr>
                <tr><td><code>depth</code></td><td>How many delegations from root</td></tr>
            </table>

            <h2 id="attenuation">Attenuation</h2>
            <p>
                When you delegate a warrant, you <strong>attenuate</strong> it, making it narrower.
                This is cryptographically enforced: child warrants cannot exceed parent capabilities.
            </p>
            <pre><code>let worker_warrant = parent_warrant.attenuate()
    .constraint("cluster", Exact::new("staging-web"))  // narrowed
    .constraint("budget", Range::max(1000.0))          // reduced
    .authorized_holder(worker_keypair.public_key())    // bound
    .build(&parent_keypair)?;</code></pre>

            <h2 id="constraints">Constraints</h2>
            <table>
                <tr><th>Type</th><th>Example</th><th>Description</th></tr>
                <tr><td><code>Wildcard</code></td><td><code>*</code></td><td>Matches anything, can narrow to any type</td></tr>
                <tr><td><code>Pattern</code></td><td><code>staging-*</code></td><td>Glob matching</td></tr>
                <tr><td><code>Exact</code></td><td><code>staging-web</code></td><td>Exact string match</td></tr>
                <tr><td><code>OneOf</code></td><td><code>["a", "b"]</code></td><td>Value must be in set</td></tr>
                <tr><td><code>Range</code></td><td><code>0..10000</code></td><td>Numeric bounds</td></tr>
                <tr><td><code>NotOneOf</code></td><td><code>!["prod"]</code></td><td>Exclude specific values</td></tr>
            </table>

            <h2 id="holder-binding">Holder Binding</h2>
            <p>
                Warrants can be bound to a holder's public key using <code>authorized_holder</code>.
                The holder must sign each request (Proof-of-Possession). Without the private key,
                the warrant cannot be used.
            </p>

            <h3>Key Generation</h3>
            <p>
                <strong>Every agent generates its own keys locally.</strong> This applies to both
                root agents (registered with Control Plane) and sub-agents (receiving delegated warrants).
                Only the public key is ever shared. The private key never leaves the agent.
            </p>
            <pre><code>Root Agent Registration:
┌──────────────────┐                    ┌──────────────────┐
│   ROOT AGENT     │                    │  CONTROL PLANE   │
│                  │   1. Send pubkey   │                  │
│  [PrivateKey]    │  ───────────────►  │  2. Register     │
│  (NEVER LEAVES)  │  ◄───────────────  │  3. Issue warrant│
└──────────────────┘                    └──────────────────┘

Sub-Agent Delegation (same principle):
┌──────────────────┐                    ┌──────────────────┐
│   SUB-AGENT      │                    │  ORCHESTRATOR    │
│                  │   1. Send pubkey   │                  │
│  [PrivateKey]    │  ───────────────►  │  2. Attenuate    │
│  (NEVER LEAVES)  │  ◄───────────────  │     warrant with │
│                  │   3. Delegated     │     holder=pubkey│
└──────────────────┘      warrant       └──────────────────┘</code></pre>
            <div class="tip">
                <p>In the demo, the orchestrator generates the worker's keypair for simplicity.
                In production, each agent should generate its own keypair and share only the public key.</p>
            </div>

            <h3>Proof-of-Possession</h3>
            <pre><code>// Orchestrator binds warrant to worker's public key
.authorized_holder(worker_keypair.public_key())

// Worker signs request with their private key
let signature = warrant.create_pop_signature(&keypair, tool, &args)?;
warrant.authorize(tool, &args, Some(&signature))?;</code></pre>

            <h2 id="multi-sig">Multi-Sig Approvals</h2>
            <p>
                Sensitive actions can require M-of-N approvals before execution.
                Approvals are cryptographically bound to the specific request.
            </p>
            <pre><code>let warrant = Warrant::builder()
    .tool("delete_database")
    .required_approvers(vec![admin1.public_key(), admin2.public_key()])
    .min_approvals(2)  // require 2-of-2
    .build(&keypair)?;</code></pre>
            <p>
                Each approver signs independently (no interactive coordination needed).
                The authorizer collects signatures and verifies that the threshold is met.
            </p>

            <h2 id="notary">Notary Registry</h2>
            <p>
                A <strong>Notary</strong> maps external identities to cryptographic keys.
                Use it to associate AWS IAM users, Okta accounts, or other identity providers
                with Ed25519 public keys.
            </p>

            <h3>Trust Hierarchy</h3>
            <p>
                The Control Plane is the root of trust. It certifies orchestrators, which
                in turn certify their child agents. Notaries are scoped to deployments.
            </p>
            <pre><code>Control Plane (Root of Trust)
    │
    ├── Certifies Orchestrator A (deployment)
    │       │
    │       ├── Bound Notary (scoped to this deployment)
    │       │       └── Maps enterprise identities → keys
    │       │
    │       ├── Worker Agent 1 (warrant from Orchestrator A)
    │       └── Worker Agent 2 (warrant from Orchestrator A)
    │
    └── Certifies Orchestrator B (different deployment)
            └── ...</code></pre>

            <h3>Deployment Binding</h3>
            <p>
                In production, notaries and key bindings should be scoped to a specific deployment.
                This prevents cross-deployment authorization attacks.
            </p>
            <pre><code>// Notary bound to a specific deployment
let admin = Notary::new("admin-1", admin_keypair.public_key())
    .with_deployment("orchestrator-prod-us-east-1");

// Key binding scoped to deployment
let binding = KeyBinding {
    provider: "aws-iam".to_string(),
    external_id: "arn:aws:iam::123456789:user/alice".to_string(),
    public_key: alice_keypair.public_key(),
    deployment_id: Some("orchestrator-prod-us-east-1".to_string()),
    // ...
};</code></pre>
            <p>
                The registry is local to each deployment. It doesn't issue keys; it just 
                records which external identity owns which public key. All key lifecycle 
                events are auditable.
            </p>

            <h3>Key Lifecycle</h3>
            <p>
                The NotaryRegistry manages the full key lifecycle with cryptographic proofs:
            </p>
            <table>
                <tr><th>Operation</th><th>Authorization</th><th>Description</th></tr>
                <tr><td><code>register_key</code></td><td>Notary + PoP</td><td>Bind identity to key (agent proves key ownership)</td></tr>
                <tr><td><code>rotate_key</code></td><td>Self (old key)</td><td>Replace key (old key signs new key)</td></tr>
                <tr><td><code>revoke_key</code></td><td>Notary</td><td>Deactivate key (for compromised keys)</td></tr>
            </table>

            <h3>Cascading Key Revocation</h3>
            <p>
                When a key is revoked, the NotaryRegistry returns all affected warrant IDs
                so they can be added to the Signed Revocation List:
            </p>
            <pre><code>// Track warrants when created
registry.track_warrant(warrant.issuer(), warrant.id());
if let Some(holder) = warrant.authorized_holder() {
    registry.track_warrant(holder, warrant.id());
}

// When key is compromised, revoke_key returns affected warrants
let affected_warrants = registry.revoke_key(
    "aws-iam", 
    "arn:...", 
    "Key compromised",
    &signature,
    &notary,
)?;

// Add affected warrants to SRL
let srl = SignedRevocationList::builder()
    .revoke_all(affected_warrants)
    .version(current_version + 1)
    .build(&control_plane_keypair)?;</code></pre>
            <p>
                This ensures that when a key is compromised, all warrants issued by or held by 
                that key are automatically identified for revocation.
            </p>
            <pre><code>// Registration: Agent generates key, sends public key + PoP
let proof = RegistrationProof::create(&agent_keypair, "aws-iam", "arn:...", now);
registry.register_key(binding, &proof, &notary)?;

// Rotation: Old key signs new key (self-authorized)
let sig = old_keypair.sign(&rotation_message);
registry.rotate_key("aws-iam", "arn:...", new_key, &sig, "system")?;

// Revocation: Notary signs (for compromised keys)
let sig = notary_keypair.sign(&revocation_message);
registry.revoke_key("aws-iam", "arn:...", "Compromised", &sig, &notary)?;</code></pre>
            <div class="tip">
                <p><strong>Deployment scoping:</strong> A notary bound to deployment A cannot register or revoke keys for deployment B.</p>
            </div>

            <h2 id="approval-flow">Approval Flow</h2>
            <p>
                The <strong>agent</strong> (or its orchestrating system) is responsible for collecting approvals.
                The Authorizer remains <strong>offline and stateless</strong>. It only verifies what's submitted.
            </p>

            <pre><code>┌─────────────────────────────────────────────────────────────┐
│  1. Warrant issued with required_approvers + min_approvals  │
│     └── "needs 2-of-3 from [Alice, Bob, Carol]"             │
│                                                             │
│  2. Agent wants to perform action                           │
│     └── Agent checks: does this warrant require approvals?  │
│                                                             │
│  3. Agent requests approval from notaries (out-of-band)     │
│     └── API call, human clicking button, hardware key, etc. │
│     └── "Please sign: hash(tool, args, warrant_id, holder)" │
│                                                             │
│  4. Notaries sign independently                             │
│     └── Alice → Approval { signature, expires_at }          │
│     └── Bob   → Approval { signature, expires_at }          │
│                                                             │
│  5. Agent collects approvals and calls Authorizer           │
│     └── authorizer.authorize(chain, tool, args, &approvals) │
│                                                             │
│  6. Authorizer verifies (no network, no state):             │
│     └── Valid signatures from required_approvers?           │
│     └── Threshold met (>= min_approvals)?                   │
│     └── No duplicate approvers?                             │
│     └── Approvals not expired?                              │
│     └── Bound to correct holder?                            │
└─────────────────────────────────────────────────────────────┘</code></pre>

            <div class="tip">
                <p><strong>Key point:</strong> The Authorizer never makes network calls. It validates cryptographic proofs. 
                How approvals are obtained is up to the application. Tenuo only defines the math.</p>
            </div>

            <h2 id="chain-verification">Chain Verification</h2>
            <p>
                When a worker presents a warrant, the authorizer verifies the <strong>entire chain</strong>
                from root to leaf:
            </p>
            <pre><code>let authorizer = Authorizer::new(root_public_key);

// Verify the full chain
let chain = vec![root_warrant, orchestrator_warrant, worker_warrant];
authorizer.verify_chain(&chain)?;

// Or verify and authorize in one step
authorizer.authorize(
    &worker_warrant,
    "upgrade",
    &args,
    Some(&pop_signature),  // Proof-of-Possession
    &approvals             // Multi-sig approvals (if required)
)?;</code></pre>
            <p>Chain verification checks:</p>
            <ul>
                <li>Root is signed by trusted issuer</li>
                <li>Each child is signed by parent's issuer</li>
                <li>Constraints only narrow (monotonicity)</li>
                <li>Depth doesn't exceed <code>max_depth</code></li>
                <li>No circular delegations (cycle detection)</li>
                <li>All warrants unexpired (with clock tolerance)</li>
            </ul>

            <h2 id="revocation">Revocation</h2>
            <p>
                Warrants can be revoked before expiration using <strong>Signed Revocation Lists (SRLs)</strong>.
                The Control Plane signs the list, and authorizers verify the signature before trusting it.
            </p>

            <h3>Revocation Flow</h3>
            <pre><code>┌──────────────────────────────────────────────────────────────────┐
│  1. Requestor creates signed RevocationRequest                   │
│     - Issuer revoking delegated warrant                          │
│     - Holder surrendering their warrant                          │
│     - Control Plane admin action                                 │
│                                                                  │
│  2. Control Plane validates request                              │
│     - Signature valid?                                           │
│     - Warrant exists? (prevents DoS with fake IDs)               │
│     - Requestor authorized? (issuer/holder/admin)                │
│     - Request fresh? (< 5 min, prevents replay)                  │
│                                                                  │
│  3. Control Plane builds and signs SRL                           │
│     - Includes all valid revocations                             │
│     - Prunes expired warrants (prevents unbounded growth)        │
│     - Increments version (anti-rollback)                         │
│                                                                  │
│  4. SRL distributed to authorizers                               │
│     - Authorizers verify signature before accepting              │
└──────────────────────────────────────────────────────────────────┘</code></pre>

            <h3>Who Can Revoke</h3>
            <table>
                <tr><th>Requestor</th><th>Can Revoke</th><th>Use Case</th></tr>
                <tr><td>Control Plane</td><td>Any warrant</td><td>Emergency revocation</td></tr>
                <tr><td>Issuer</td><td>Warrants they issued</td><td>Revoking delegated authority</td></tr>
                <tr><td>Holder</td><td>Their own warrant</td><td>Voluntary surrender (key compromise)</td></tr>
            </table>

            <h3>Code Example</h3>
            <pre><code>// Agent requests revocation (e.g., key compromise)
let request = RevocationRequest::new(
    warrant.id(),
    "Key compromise detected",
    &agent_keypair,
)?;

// Control Plane validates and builds SRL
request.validate(
    warrant.id().as_str(),
    warrant.issuer(),
    warrant.authorized_holder(),
    warrant.expires_at(),
    &control_plane_key,
)?;

let srl = SignedRevocationList::builder()
    .revoke(warrant.id())
    .version(current_version + 1)
    .build(&control_plane_keypair)?;

// Authorizer loads SRL (verifies signature)
authorizer.set_revocation_list(srl, &control_plane_key)?;

// Verification now fails
authorizer.verify(&warrant);  // Error: WarrantRevoked</code></pre>

            <h3>Cascading Revocation</h3>
            <p>
                Revocation in Tenuo is hierarchical, giving you precise control:
            </p>
            
            <table>
                <tr><th>Mode</th><th>What to Revoke</th><th>Effect</th></tr>
                <tr>
                    <td><strong>Surgical</strong></td>
                    <td>Specific Warrant ID</td>
                    <td>Stops that single task. Other warrants from the same agent remain valid.</td>
                </tr>
                <tr>
                    <td><strong>Nuclear</strong></td>
                    <td>Agent's Public Key</td>
                    <td>Instantly invalidates every warrant that agent ever issued. Kill an entire swarm of 10,000 sub-agents with a single switch.</td>
                </tr>
            </table>

            <pre><code>// SURGICAL: Revoke one warrant
srl.revoke(bad_warrant.id());

// NUCLEAR: Revoke all warrants from a compromised key
// Control Plane tracks which warrants each key issued/holds
let affected_ids = registry.revoke_key("aws-iam", "compromised-agent", ...)?;
let srl = manager.generate_srl_with_cascade(&cp_keypair, v, affected_ids)?;</code></pre>

            <p>
                The authorizer checks ALL warrants in a chain against the SRL. 
                Revoking any warrant in the chain breaks the entire chain:
            </p>
            <pre><code>// Revoke the root
srl.revoke(root.id());

// Entire chain is now invalid (root, child, grandchild all fail)
authorizer.verify_chain(&[root, child, grandchild]);  // Error: WarrantRevoked</code></pre>

            <div class="tip">
                <p><strong>DoS Protection:</strong> Revocation requests are cryptographically validated. 
                The Control Plane only processes requests for warrants it knows exist.</p>
            </div>

            <h3>Telemetry ≠ Enforcement</h3>
            <p>
                Tenuo deliberately decouples <strong>monitoring</strong> from <strong>authorization</strong>:
            </p>
            <table>
                <tr><th></th><th>Authorization (Enforcement)</th><th>Monitoring (Telemetry)</th></tr>
                <tr>
                    <td><strong>How</strong></td>
                    <td>Offline cryptography</td>
                    <td>Standard logging (DataDog, Splunk, etc.)</td>
                </tr>
                <tr>
                    <td><strong>Availability</strong></td>
                    <td>Never fails due to network partitions</td>
                    <td>Eventual consistency, best-effort</td>
                </tr>
                <tr>
                    <td><strong>Latency</strong></td>
                    <td>~25μs (hot path)</td>
                    <td>Async, does not block</td>
                </tr>
            </table>
            <p>
                This means the Control Plane does not automatically know every attenuated warrant ID.
                For surgical revocation of a specific worker, you need telemetry:
            </p>
            <pre><code>// SDK emits structured logs during attenuation
// Your logging pipeline captures: parent_id, child_id, holder_key
orchestrator.attenuate_logged(&parent, &worker_key, &constraints)?;

// When you need to revoke, query your logs
let worker_warrant_id = telemetry.query("holder_key = ?", compromised_key);
srl.revoke(worker_warrant_id);</code></pre>
            <div class="tip">
                <p><strong>Why this design?</strong> Your security layer should never become a bottleneck. 
                Authorization is synchronous and must be fast. Telemetry is async and can be eventual.
                Coupling them means network failures block your agent swarm.</p>
            </div>

            <h2 id="planes">Control vs Data Plane</h2>
            <p>
                Tenuo separates concerns into two planes that can run in different security contexts:
            </p>
            <table>
                <tr><th>Control Plane</th><th>Data Plane</th></tr>
                <tr><td>Issues root warrants</td><td>Verifies warrant chains</td></tr>
                <tr><td>Holds root private key</td><td>Only has root public key</td></tr>
                <tr><td>Manages policy</td><td>Enforces policy</td></tr>
                <tr><td>Single secure instance</td><td>Distributed (gateway/sidecar)</td></tr>
                <tr><td>Network accessible</td><td>100% offline verification</td></tr>
            </table>
            <pre><code>// Control Plane (secure environment)
let control_plane = ControlPlane::new(root_keypair);
let warrant = control_plane.issue_warrant("tool", &constraints, ttl)?;

// Data Plane (distributed, e.g., sidecar)
let authorizer = Authorizer::new(control_plane.public_key());
authorizer.authorize(&warrant, "tool", &args, signature, &[])?;</code></pre>
            <p>
                <a href="../architecture-infographic.html">View the architecture diagram →</a>
            </p>

            <h2 id="properties">Security Properties</h2>
            <table>
                <tr><th>Property</th><th>Description</th></tr>
                <tr><td>Offline verification</td><td>No network calls needed</td></tr>
                <tr><td>Monotonic attenuation</td><td>Capabilities only shrink</td></tr>
                <tr><td>Holder binding</td><td>Stolen tokens are useless</td></tr>
                <tr><td>Depth limits</td><td>Max 64 delegation levels</td></tr>
                <tr><td>Constraint depth</td><td>Max 16 nesting levels</td></tr>
                <tr><td>Payload size</td><td>Max 1MB per warrant</td></tr>
            </table>
        </main>
    </div>

    <script>
        // Toggle sections on click
        document.querySelectorAll('.sidebar-title').forEach(title => {
            title.addEventListener('click', () => {
                title.parentElement.classList.toggle('expanded');
            });
        });

        // Scroll spy: highlight active link and expand its section
        const links = document.querySelectorAll('.sidebar-link[href^="#"]');
        const sections = [...links].map(link => document.querySelector(link.getAttribute('href'))).filter(Boolean);

        function updateActiveLink() {
            let current = sections[0];
            const scrollPos = window.scrollY + 100;

            for (const section of sections) {
                if (section.offsetTop <= scrollPos) {
                    current = section;
                }
            }

            links.forEach(link => {
                const isActive = link.getAttribute('href') === '#' + current.id;
                link.classList.toggle('active', isActive);
                if (isActive) {
                    link.closest('.sidebar-section').classList.add('expanded');
                }
            });
        }

        window.addEventListener('scroll', updateActiveLink);
        updateActiveLink();
    </script>
</body>
</html>
