<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tenuo Docs</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #0a0a0a;
            --surface: #141414;
            --border: #262626;
            --text: #fafafa;
            --muted: #a1a1a1;
            --accent: #00d4ff;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.7;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 56px;
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(8px);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .header-logo {
            font-weight: 700;
            font-size: 1.25rem;
            letter-spacing: -0.5px;
        }

        .header-logo a {
            color: var(--text);
            text-decoration: none;
        }

        .layout {
            display: flex;
            min-height: 100vh;
            padding-top: 56px;
        }

        /* Sidebar */
        .sidebar {
            width: 240px;
            border-right: 1px solid var(--border);
            padding: 24px 16px;
            position: fixed;
            top: 56px;
            bottom: 0;
            overflow-y: auto;
        }

        .sidebar-section {
            margin-bottom: 8px;
        }

        .sidebar-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--muted);
            padding: 8px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-radius: 6px;
            transition: all 0.15s;
            user-select: none;
        }

        .sidebar-title:hover {
            background: var(--surface);
            color: var(--text);
        }

        .sidebar-title::after {
            content: '+';
            font-size: 1rem;
            font-weight: 300;
            opacity: 0.5;
        }

        .sidebar-section.expanded .sidebar-title::after {
            content: 'âˆ’';
        }

        .sidebar-links {
            overflow: hidden;
            max-height: 0;
            transition: max-height 0.25s ease;
        }

        .sidebar-section.expanded .sidebar-links {
            max-height: 500px;
        }

        .sidebar-link {
            display: block;
            padding: 6px 12px 6px 20px;
            margin: 2px 0;
            border-radius: 6px;
            color: var(--muted);
            text-decoration: none;
            font-size: 0.85rem;
            transition: all 0.15s;
        }

        .sidebar-link:hover {
            background: var(--surface);
            color: var(--text);
        }

        .sidebar-link.active {
            background: var(--surface);
            color: var(--accent);
        }

        /* Main content */
        .main {
            flex: 1;
            margin-left: 240px;
            padding: 40px 64px 80px;
            max-width: 800px;
        }

        h1 {
            font-size: 2rem;
            font-weight: 600;
            margin-bottom: 16px;
        }

        h2 {
            font-size: 1.4rem;
            font-weight: 600;
            margin: 48px 0 16px;
            padding-top: 24px;
            border-top: 1px solid var(--border);
        }

        h3 {
            font-size: 1.1rem;
            font-weight: 600;
            margin: 32px 0 12px;
        }

        p {
            color: var(--muted);
            margin-bottom: 16px;
        }

        p strong { color: var(--text); }

        code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85em;
            background: var(--surface);
            padding: 2px 6px;
            border-radius: 4px;
        }

        pre {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            overflow-x: auto;
            margin: 16px 0;
        }

        pre code {
            background: none;
            padding: 0;
        }

        .tip {
            background: rgba(0, 212, 255, 0.1);
            border-left: 3px solid var(--accent);
            padding: 12px 16px;
            margin: 16px 0;
            border-radius: 0 8px 8px 0;
        }

        .tip p { margin: 0; color: var(--text); }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 16px 0;
            font-size: 0.9rem;
        }

        th, td {
            text-align: left;
            padding: 12px;
            border-bottom: 1px solid var(--border);
        }

        th { color: var(--text); font-weight: 500; }
        td { color: var(--muted); }

        a { color: var(--accent); text-decoration: none; }
        a:hover { opacity: 0.8; }

        ul, ol {
            margin: 16px 0;
            padding-left: 24px;
            color: var(--muted);
        }

        li { margin: 8px 0; }
        li strong { color: var(--text); }

        @media (max-width: 900px) {
            .sidebar { display: none; }
            .main { margin-left: 0; padding: 24px 20px 60px; }
        }

        /* Scroll offset for fixed header */
        h1[id], h2[id], h3[id] {
            scroll-margin-top: 80px;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-logo"><a href="../">tenuo</a></div>
    </header>

    <div class="layout">
        <aside class="sidebar">
            <div class="sidebar-section">
                <div class="sidebar-title">Getting Started</div>
                <div class="sidebar-links">
                    <a href="#introduction" class="sidebar-link">Introduction</a>
                    <a href="#quick-start" class="sidebar-link">Quick Start</a>
                    <a href="#demo" class="sidebar-link">Demo</a>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title">Concepts</div>
                <div class="sidebar-links">
                    <a href="#warrants" class="sidebar-link">Warrants</a>
                    <a href="#attenuation" class="sidebar-link">Attenuation</a>
                    <a href="#constraints" class="sidebar-link">Constraints</a>
                    <a href="#holder-binding" class="sidebar-link">Holder Binding</a>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title">Approvals</div>
                <div class="sidebar-links">
                    <a href="#multi-sig" class="sidebar-link">Multi-Sig</a>
                    <a href="#notary" class="sidebar-link">Notary Registry</a>
                    <a href="#approval-flow" class="sidebar-link">Approval Flow</a>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title">Verification</div>
                <div class="sidebar-links">
                    <a href="#chain-verification" class="sidebar-link">Chain Verification</a>
                    <a href="#revocation" class="sidebar-link">Revocation</a>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title">Integration</div>
                <div class="sidebar-links">
                    <a href="#user-journey" class="sidebar-link">User Journey</a>
                    <a href="#gateway-config" class="sidebar-link">Gateway Config</a>
                    <a href="#extraction" class="sidebar-link">Constraint Extraction</a>
                    <a href="#dry-run" class="sidebar-link">Testing (Dry Run)</a>
                    <a href="#mcp-integration" class="sidebar-link">MCP Integration</a>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title">Architecture</div>
                <div class="sidebar-links">
                    <a href="#planes" class="sidebar-link">Control vs Data Plane</a>
                    <a href="#properties" class="sidebar-link">Security Properties</a>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title">Reference</div>
                <div class="sidebar-links">
                    <a href="https://github.com/tenuo/tenuo/blob/main/README.md" class="sidebar-link">README</a>
                    <a href="https://docs.rs/tenuo-core" class="sidebar-link">API Docs â†—</a>
                </div>
            </div>
        </aside>

        <main class="main">
            <h1 id="introduction">Introduction</h1>
            <p>
                Tenuo is a capability-based authorization library for AI agent workflows.
                It uses signed tokens called <strong>warrants</strong> to control what actions agents can perform.
            </p>
            <p>
                The core invariant: when a warrant is delegated, its capabilities can only <strong>shrink</strong>.
                A $1000 budget becomes $500. Access to <code>staging-*</code> narrows to <code>staging-web</code>.
            </p>
            <p>
                Verification is local (no network calls required). Typical latency is ~25Î¼s.
            </p>

            <h3>Where Tenuo Fits</h3>
            <p>
                Tenuo operates <strong>above</strong> your infrastructure's IAM layer. It doesn't replace it.
            </p>
            <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Agent Request                                          â”‚
â”‚  "I want to restart staging-web"                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Tenuo Layer (Application)                              â”‚
â”‚  âœ“ Does this warrant allow "restart" on "staging-web"?  â”‚
â”‚  âœ“ Is the delegation chain valid?                       â”‚
â”‚  âœ“ Is the holder's signature correct?                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Infrastructure IAM (AWS IAM / K8s RBAC / etc.)         â”‚
â”‚  âœ“ Does this service account have permission?           â”‚
â”‚  âœ“ Is the network policy satisfied?                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
            <p>
                Your microservices still use their existing IAM (AWS roles, Kubernetes service accounts, etc.).
                Tenuo adds a <strong>delegation layer</strong> that tracks <em>why</em> an agent is acting and 
                <em>what limits</em> apply to that specific task. Infrastructure IAM can't express this.
            </p>
            <div class="tip">
                <p>Think of it this way: IAM answers "can this service call this API?" 
                Tenuo answers "who delegated this authority, what task context does it carry, and is this action within those bounds?"</p>
            </div>
            <p>
                Warrants carry context through the delegation chain. A constraint like 
                <code>order_status == 'approved'</code> ties an agent's capabilities to 
                actions performed earlier in the workflow. The <code>session_id</code> binds 
                the entire chain to a specific task.
            </p>

            <h2 id="quick-start">Quick Start</h2>
            <p>Add to your Rust project:</p>
            <pre><code>[dependencies]
tenuo-core = "0.1"</code></pre>

            <p><strong>1. Create a warrant</strong></p>
            <pre><code>use tenuo_core::{Keypair, Warrant, Pattern, Range};
use std::time::Duration;

let keypair = Keypair::generate();
let warrant = Warrant::builder()
    .tool("manage_infrastructure")
    .constraint("cluster", Pattern::new("staging-*")?)
    .constraint("budget", Range::max(1000.0))
    .ttl(Duration::from_secs(3600))
    .build(&keypair)?;</code></pre>

            <p><strong>2. Attenuate and delegate</strong></p>
            <pre><code>let worker_keypair = Keypair::generate();
let worker_warrant = warrant.attenuate()
    .constraint("cluster", Exact::new("staging-web"))
    .constraint("budget", Range::max(100.0))
    .authorized_holder(worker_keypair.public_key())
    .build(&keypair)?;</code></pre>

            <p><strong>3. Verify and authorize</strong></p>
            <pre><code>use tenuo_core::Authorizer;

let authorizer = Authorizer::new(keypair.public_key());
let chain = vec![warrant, worker_warrant];

// Worker signs the request (Proof-of-Possession)
let sig = worker_warrant.create_pop_signature(
    "manage_infrastructure", &args, &worker_keypair
);

authorizer.authorize(&chain, "manage_infrastructure", &args, Some(&sig), &[])?;</code></pre>

            <h2 id="demo">Demo</h2>
            <p>
                See the full flow in action with Docker:
            </p>
            <pre><code>docker compose up orchestrator worker</code></pre>
            <p>
                <a href="../demo-infographic.html">View the interactive infographic â†’</a>
            </p>

            <h2 id="warrants">Warrants</h2>
            <p>
                A <strong>warrant</strong> is a signed token that authorizes a specific action with specific constraints.
                Every warrant contains:
            </p>
            <table>
                <tr><th>Field</th><th>Description</th></tr>
                <tr><td><code>id</code></td><td>Unique identifier (UUIDv7)</td></tr>
                <tr><td><code>tool</code></td><td>What action is authorized</td></tr>
                <tr><td><code>constraints</code></td><td>Restrictions on arguments</td></tr>
                <tr><td><code>expires_at</code></td><td>When the warrant expires</td></tr>
                <tr><td><code>issuer</code></td><td>Who signed this warrant</td></tr>
                <tr><td><code>depth</code></td><td>How many delegations from root</td></tr>
            </table>

            <h2 id="attenuation">Attenuation</h2>
            <p>
                When you delegate a warrant, you <strong>attenuate</strong> it, making it narrower.
                This is cryptographically enforced: child warrants cannot exceed parent capabilities.
            </p>
            <pre><code>let worker_warrant = parent_warrant.attenuate()
    .constraint("cluster", Exact::new("staging-web"))  // narrowed
    .constraint("budget", Range::max(1000.0))          // reduced
    .authorized_holder(worker_keypair.public_key())    // bound
    .build(&parent_keypair)?;</code></pre>

            <h2 id="constraints">Constraints</h2>
            <table>
                <tr><th>Type</th><th>Example</th><th>Description</th></tr>
                <tr><td><code>Wildcard</code></td><td><code>*</code></td><td>Matches anything, can narrow to any type</td></tr>
                <tr><td><code>Pattern</code></td><td><code>staging-*</code></td><td>Glob matching</td></tr>
                <tr><td><code>Exact</code></td><td><code>staging-web</code></td><td>Exact string match</td></tr>
                <tr><td><code>OneOf</code></td><td><code>["a", "b"]</code></td><td>Value must be in set</td></tr>
                <tr><td><code>Range</code></td><td><code>0..10000</code></td><td>Numeric bounds</td></tr>
                <tr><td><code>NotOneOf</code></td><td><code>!["prod"]</code></td><td>Exclude specific values</td></tr>
            </table>

            <h2 id="holder-binding">Holder Binding</h2>
            <p>
                Warrants can be bound to a holder's public key using <code>authorized_holder</code>.
                The holder must sign each request (Proof-of-Possession). Without the private key,
                the warrant cannot be used.
            </p>

            <h3>Key Generation</h3>
            <p>
                <strong>Every agent generates its own keys locally.</strong> This applies to both
                root agents (registered with Control Plane) and sub-agents (receiving delegated warrants).
                Only the public key is ever shared. The private key never leaves the agent.
            </p>
            <pre><code>Root Agent Registration:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ROOT AGENT     â”‚                    â”‚  CONTROL PLANE   â”‚
â”‚                  â”‚   1. Send pubkey   â”‚                  â”‚
â”‚  [PrivateKey]    â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  â”‚  2. Register     â”‚
â”‚  (NEVER LEAVES)  â”‚  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚  3. Issue warrantâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Sub-Agent Delegation (same principle):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   SUB-AGENT      â”‚                    â”‚  ORCHESTRATOR    â”‚
â”‚                  â”‚   1. Send pubkey   â”‚                  â”‚
â”‚  [PrivateKey]    â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  â”‚  2. Attenuate    â”‚
â”‚  (NEVER LEAVES)  â”‚  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚     warrant with â”‚
â”‚                  â”‚   3. Delegated     â”‚     holder=pubkeyâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      warrant       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
            <div class="tip">
                <p>In the demo, the orchestrator generates the worker's keypair for simplicity.
                In production, each agent should generate its own keypair and share only the public key.</p>
            </div>

            <h3>Proof-of-Possession</h3>
            <pre><code>// Orchestrator binds warrant to worker's public key
.authorized_holder(worker_keypair.public_key())

// Worker signs request with their private key
let signature = warrant.create_pop_signature(&keypair, tool, &args)?;
warrant.authorize(tool, &args, Some(&signature))?;</code></pre>

            <h2 id="multi-sig">Multi-Sig Approvals</h2>
            <p>
                Sensitive actions can require M-of-N approvals before execution.
                Approvals are cryptographically bound to the specific request.
            </p>
            <pre><code>let warrant = Warrant::builder()
    .tool("delete_database")
    .required_approvers(vec![admin1.public_key(), admin2.public_key()])
    .min_approvals(2)  // require 2-of-2
    .build(&keypair)?;</code></pre>
            <p>
                Each approver signs independently (no interactive coordination needed).
                The authorizer collects signatures and verifies that the threshold is met.
            </p>

            <h2 id="notary">Notary Registry</h2>
            <p>
                A <strong>Notary</strong> maps external identities to cryptographic keys.
                Use it to associate AWS IAM users, Okta accounts, or other identity providers
                with Ed25519 public keys.
            </p>

            <h3>Trust Hierarchy</h3>
            <p>
                The Control Plane is the root of trust. It certifies orchestrators, which
                in turn certify their child agents. Notaries are scoped to deployments.
            </p>
            <pre><code>Control Plane (Root of Trust)
    â”‚
    â”œâ”€â”€ Certifies Orchestrator A (deployment)
    â”‚       â”‚
    â”‚       â”œâ”€â”€ Bound Notary (scoped to this deployment)
    â”‚       â”‚       â””â”€â”€ Maps enterprise identities â†’ keys
    â”‚       â”‚
    â”‚       â”œâ”€â”€ Worker Agent 1 (warrant from Orchestrator A)
    â”‚       â””â”€â”€ Worker Agent 2 (warrant from Orchestrator A)
    â”‚
    â””â”€â”€ Certifies Orchestrator B (different deployment)
            â””â”€â”€ ...</code></pre>

            <h3>Deployment Binding</h3>
            <p>
                In production, notaries and key bindings should be scoped to a specific deployment.
                This prevents cross-deployment authorization attacks.
            </p>
            <pre><code>// Notary bound to a specific deployment
let admin = Notary::new("admin-1", admin_keypair.public_key())
    .with_deployment("orchestrator-prod-us-east-1");

// Key binding scoped to deployment
let binding = KeyBinding {
    provider: "aws-iam".to_string(),
    external_id: "arn:aws:iam::123456789:user/alice".to_string(),
    public_key: alice_keypair.public_key(),
    deployment_id: Some("orchestrator-prod-us-east-1".to_string()),
    // ...
};</code></pre>
            <p>
                The registry is local to each deployment. It doesn't issue keys; it just 
                records which external identity owns which public key. All key lifecycle 
                events are auditable.
            </p>

            <h3>Key Lifecycle</h3>
            <p>
                The NotaryRegistry manages the full key lifecycle with cryptographic proofs:
            </p>
            <table>
                <tr><th>Operation</th><th>Authorization</th><th>Description</th></tr>
                <tr><td><code>register_key</code></td><td>Notary + PoP</td><td>Bind identity to key (agent proves key ownership)</td></tr>
                <tr><td><code>rotate_key</code></td><td>Self (old key)</td><td>Replace key (old key signs new key)</td></tr>
                <tr><td><code>revoke_key</code></td><td>Notary</td><td>Deactivate key (for compromised keys)</td></tr>
            </table>

            <h3>Cascading Key Revocation</h3>
            <p>
                When a key is revoked, the NotaryRegistry returns all affected warrant IDs
                so they can be added to the Signed Revocation List:
            </p>
            <pre><code>// Track warrants when created
registry.track_warrant(warrant.issuer(), warrant.id());
if let Some(holder) = warrant.authorized_holder() {
    registry.track_warrant(holder, warrant.id());
}

// When key is compromised, revoke_key returns affected warrants
let affected_warrants = registry.revoke_key(
    "aws-iam", 
    "arn:...", 
    "Key compromised",
    &signature,
    &notary,
)?;

// Add affected warrants to SRL
let srl = SignedRevocationList::builder()
    .revoke_all(affected_warrants)
    .version(current_version + 1)
    .build(&control_plane_keypair)?;</code></pre>
            <p>
                This ensures that when a key is compromised, all warrants issued by or held by 
                that key are automatically identified for revocation.
            </p>
            <pre><code>// Registration: Agent generates key, sends public key + PoP
let proof = RegistrationProof::create(&agent_keypair, "aws-iam", "arn:...", now);
registry.register_key(binding, &proof, &notary)?;

// Rotation: Old key signs new key (self-authorized)
let sig = old_keypair.sign(&rotation_message);
registry.rotate_key("aws-iam", "arn:...", new_key, &sig, "system")?;

// Revocation: Notary signs (for compromised keys)
let sig = notary_keypair.sign(&revocation_message);
registry.revoke_key("aws-iam", "arn:...", "Compromised", &sig, &notary)?;</code></pre>
            <div class="tip">
                <p><strong>Deployment scoping:</strong> A notary bound to deployment A cannot register or revoke keys for deployment B.</p>
            </div>

            <h2 id="approval-flow">Approval Flow</h2>
            <p>
                The <strong>agent</strong> (or its orchestrating system) is responsible for collecting approvals.
                The Authorizer remains <strong>offline and stateless</strong>. It only verifies what's submitted.
            </p>

            <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. Warrant issued with required_approvers + min_approvals  â”‚
â”‚     â””â”€â”€ "needs 2-of-3 from [Alice, Bob, Carol]"             â”‚
â”‚                                                             â”‚
â”‚  2. Agent wants to perform action                           â”‚
â”‚     â””â”€â”€ Agent checks: does this warrant require approvals?  â”‚
â”‚                                                             â”‚
â”‚  3. Agent requests approval from notaries (out-of-band)     â”‚
â”‚     â””â”€â”€ API call, human clicking button, hardware key, etc. â”‚
â”‚     â””â”€â”€ "Please sign: hash(tool, args, warrant_id, holder)" â”‚
â”‚                                                             â”‚
â”‚  4. Notaries sign independently                             â”‚
â”‚     â””â”€â”€ Alice â†’ Approval { signature, expires_at }          â”‚
â”‚     â””â”€â”€ Bob   â†’ Approval { signature, expires_at }          â”‚
â”‚                                                             â”‚
â”‚  5. Agent collects approvals and calls Authorizer           â”‚
â”‚     â””â”€â”€ authorizer.authorize(chain, tool, args, &approvals) â”‚
â”‚                                                             â”‚
â”‚  6. Authorizer verifies (no network, no state):             â”‚
â”‚     â””â”€â”€ Valid signatures from required_approvers?           â”‚
â”‚     â””â”€â”€ Threshold met (>= min_approvals)?                   â”‚
â”‚     â””â”€â”€ No duplicate approvers?                             â”‚
â”‚     â””â”€â”€ Approvals not expired?                              â”‚
â”‚     â””â”€â”€ Bound to correct holder?                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

            <div class="tip">
                <p><strong>Key point:</strong> The Authorizer never makes network calls. It validates cryptographic proofs. 
                How approvals are obtained is up to the application. Tenuo only defines the math.</p>
            </div>

            <h2 id="chain-verification">Chain Verification</h2>
            <p>
                When a worker presents a warrant, the authorizer verifies the <strong>entire chain</strong>
                from root to leaf:
            </p>
            <pre><code>let authorizer = Authorizer::new(root_public_key);

// Verify the full chain
let chain = vec![root_warrant, orchestrator_warrant, worker_warrant];
authorizer.verify_chain(&chain)?;

// Or verify and authorize in one step
authorizer.authorize(
    &worker_warrant,
    "upgrade",
    &args,
    Some(&pop_signature),  // Proof-of-Possession
    &approvals             // Multi-sig approvals (if required)
)?;</code></pre>
            <p>Chain verification checks:</p>
            <ul>
                <li>Root is signed by trusted issuer</li>
                <li>Each child is signed by parent's issuer</li>
                <li>Constraints only narrow (monotonicity)</li>
                <li>Depth doesn't exceed <code>max_depth</code></li>
                <li>No circular delegations (cycle detection)</li>
                <li>All warrants unexpired (with clock tolerance)</li>
            </ul>

            <h2 id="revocation">Revocation</h2>
            <p>
                Warrants can be revoked before expiration using <strong>Signed Revocation Lists (SRLs)</strong>.
                The Control Plane signs the list, and authorizers verify the signature before trusting it.
            </p>

            <h3>Revocation Flow</h3>
            <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. Requestor creates signed RevocationRequest                   â”‚
â”‚     - Issuer revoking delegated warrant                          â”‚
â”‚     - Holder surrendering their warrant                          â”‚
â”‚     - Control Plane admin action                                 â”‚
â”‚                                                                  â”‚
â”‚  2. Control Plane validates request                              â”‚
â”‚     - Signature valid?                                           â”‚
â”‚     - Warrant exists? (prevents DoS with fake IDs)               â”‚
â”‚     - Requestor authorized? (issuer/holder/admin)                â”‚
â”‚     - Request fresh? (< 5 min, prevents replay)                  â”‚
â”‚                                                                  â”‚
â”‚  3. Control Plane builds and signs SRL                           â”‚
â”‚     - Includes all valid revocations                             â”‚
â”‚     - Prunes expired warrants (prevents unbounded growth)        â”‚
â”‚     - Increments version (anti-rollback)                         â”‚
â”‚                                                                  â”‚
â”‚  4. SRL distributed to authorizers                               â”‚
â”‚     - Authorizers verify signature before accepting              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

            <h3>Who Can Revoke</h3>
            <table>
                <tr><th>Requestor</th><th>Can Revoke</th><th>Use Case</th></tr>
                <tr><td>Control Plane</td><td>Any warrant</td><td>Emergency revocation</td></tr>
                <tr><td>Issuer</td><td>Warrants they issued</td><td>Revoking delegated authority</td></tr>
                <tr><td>Holder</td><td>Their own warrant</td><td>Voluntary surrender (key compromise)</td></tr>
            </table>

            <h3>Code Example</h3>
            <pre><code>// Agent requests revocation (e.g., key compromise)
let request = RevocationRequest::new(
    warrant.id(),
    "Key compromise detected",
    &agent_keypair,
)?;

// Control Plane validates and builds SRL
request.validate(
    warrant.id().as_str(),
    warrant.issuer(),
    warrant.authorized_holder(),
    warrant.expires_at(),
    &control_plane_key,
)?;

let srl = SignedRevocationList::builder()
    .revoke(warrant.id())
    .version(current_version + 1)
    .build(&control_plane_keypair)?;

// Authorizer loads SRL (verifies signature)
authorizer.set_revocation_list(srl, &control_plane_key)?;

// Verification now fails
authorizer.verify(&warrant);  // Error: WarrantRevoked</code></pre>

            <h3>Cascading Revocation</h3>
            <p>
                Revocation in Tenuo is hierarchical, giving you precise control:
            </p>
            
            <table>
                <tr><th>Mode</th><th>What to Revoke</th><th>Effect</th></tr>
                <tr>
                    <td><strong>Surgical</strong></td>
                    <td>Specific Warrant ID</td>
                    <td>Stops that single task. Other warrants from the same agent remain valid.</td>
                </tr>
                <tr>
                    <td><strong>Nuclear</strong></td>
                    <td>Agent's Public Key</td>
                    <td>Instantly invalidates every warrant that agent ever issued. Kill an entire swarm of 10,000 sub-agents with a single switch.</td>
                </tr>
            </table>

            <pre><code>// SURGICAL: Revoke one warrant
srl.revoke(bad_warrant.id());

// NUCLEAR: Revoke all warrants from a compromised key
// Control Plane tracks which warrants each key issued/holds
let affected_ids = registry.revoke_key("aws-iam", "compromised-agent", ...)?;
let srl = manager.generate_srl_with_cascade(&cp_keypair, v, affected_ids)?;</code></pre>

            <p>
                The authorizer checks ALL warrants in a chain against the SRL. 
                Revoking any warrant in the chain breaks the entire chain:
            </p>
            <pre><code>// Revoke the root
srl.revoke(root.id());

// Entire chain is now invalid (root, child, grandchild all fail)
authorizer.verify_chain(&[root, child, grandchild]);  // Error: WarrantRevoked</code></pre>

            <div class="tip">
                <p><strong>DoS Protection:</strong> Revocation requests are cryptographically validated. 
                The Control Plane only processes requests for warrants it knows exist.</p>
            </div>

            <h3>Telemetry â‰  Enforcement</h3>
            <p>
                Tenuo deliberately decouples <strong>monitoring</strong> from <strong>authorization</strong>:
            </p>
            <table>
                <tr><th></th><th>Authorization (Enforcement)</th><th>Monitoring (Telemetry)</th></tr>
                <tr>
                    <td><strong>How</strong></td>
                    <td>Offline cryptography</td>
                    <td>Standard logging (DataDog, Splunk, etc.)</td>
                </tr>
                <tr>
                    <td><strong>Availability</strong></td>
                    <td>Never fails due to network partitions</td>
                    <td>Eventual consistency, best-effort</td>
                </tr>
                <tr>
                    <td><strong>Latency</strong></td>
                    <td>~25Î¼s (hot path)</td>
                    <td>Async, does not block</td>
                </tr>
            </table>
            <p>
                This means the Control Plane does not automatically know every attenuated warrant ID.
                For surgical revocation of a specific worker, you need telemetry:
            </p>
            <pre><code>// SDK emits structured logs during attenuation
// Your logging pipeline captures: parent_id, child_id, holder_key
orchestrator.attenuate_logged(&parent, &worker_key, &constraints)?;

// When you need to revoke, query your logs
let worker_warrant_id = telemetry.query("holder_key = ?", compromised_key);
srl.revoke(worker_warrant_id);</code></pre>
            <div class="tip">
                <p><strong>Why this design?</strong> Your security layer should never become a bottleneck. 
                Authorization is synchronous and must be fast. Telemetry is async and can be eventual.
                Coupling them means network failures block your agent swarm.</p>
            </div>

            <h2 id="user-journey">User Journey</h2>
            <p>
                Integrating Tenuo into your agent infrastructure follows a clear path from setup to enforcement.
                <a href="../journey-infographic.html">View the full visual guide â†’</a>
            </p>

            <h3>1. Deploy Control Plane</h3>
            <p>Start the Control Plane service. It generates its root keypair and becomes your trust anchor.</p>
            <pre><code>$ tenuo-control --bind 0.0.0.0:8080 \
    --enrollment-token $(openssl rand -hex 32)</code></pre>

            <h3>2. Configure Gateway</h3>
            <p>Define how HTTP request fields map to warrant constraints using a YAML configuration file.</p>
            <pre><code># gateway-config.yaml
tools:
  manage_cluster:
    constraints:
      cluster:
        from: path
        path: "cluster"
        required: true
      cost:
        from: body
        path: "metadata.estimatedCost"
        type: float</code></pre>

            <h3>3. Enroll Agents</h3>
            <p>Orchestrators generate their own keypairs and enroll with the Control Plane to receive root warrants.</p>
            <pre><code>let keypair = Keypair::generate();

// Enroll with Control Plane
POST /v1/enroll {
  "public_key": "a1b2c3...",
  "signature": "...",  // PoP
  "constraints": { "cluster": "staging-*" }
}</code></pre>

            <h3>4. Attenuate & Delegate</h3>
            <p>Parent agents attenuate warrants before delegating to children. Constraints can only shrink.</p>
            <pre><code>let child = parent.attenuate()
    .constraint("cluster", Exact::new("staging-web"))
    .constraint("cost", Range::new(0.0, 100.0))
    .build(&worker_keypair)?;</code></pre>

            <h3>5. Extract & Authorize</h3>
            <p>The gateway extracts values from incoming requests, verifies the warrant chain, and checks constraints.</p>
            <pre><code>POST /api/v1/clusters/staging-web/scale
X-Tenuo-Chain: &lt;base64 warrant chain&gt;
X-Tenuo-PoP: &lt;signature&gt;

// Extracted constraints:
// cluster: "staging-web" âœ“ matches Exact
// cost: 50.0 âœ“ within Range(0, 100)</code></pre>

            <h2 id="gateway-config">Gateway Configuration</h2>
            <p>
                The gateway configuration file defines how to extract constraint values from HTTP requests
                and map them to warrant constraints for authorization.
            </p>
            <p><a href="https://github.com/tenuo/tenuo/blob/main/examples/gateway-config.yaml">See full example â†’</a></p>

            <h3>Extraction Sources</h3>
            <table>
                <tr><th>Source</th><th>Syntax</th><th>Example</th></tr>
                <tr><td><code>path</code></td><td>URL path parameter</td><td><code>/api/{cluster}/action</code></td></tr>
                <tr><td><code>query</code></td><td>Query string</td><td><code>?namespace=default</code></td></tr>
                <tr><td><code>header</code></td><td>HTTP header</td><td><code>X-Tenant-Id</code></td></tr>
                <tr><td><code>body</code></td><td>JSON body (dot notation)</td><td><code>spec.replicas</code></td></tr>
            </table>

            <h3 id="extraction">JSONPath Extraction</h3>
            <p>
                Body extraction uses dot notation to navigate nested JSON structures.
            </p>
            <pre><code>// Request body:
{ "spec": { "replicas": 5 }, "items": [{ "id": "a" }, { "id": "b" }] }

// Extraction paths:
"spec.replicas"   â†’ 5 (Integer)
"items.0.id"      â†’ "a" (String)
"items.*.id"      â†’ ["a", "b"] (List)</code></pre>
            <div class="tip">
                <p><strong>Wildcard extraction:</strong> Paths like <code>items.*.id</code> produce Lists.
                Use <code>CEL</code> constraints for list operations: <code>items.all(x, x.cost < 100)</code></p>
            </div>

            <h3>Type Preservation</h3>
            <p>
                Integers are preserved for precision with large IDs (snowflakes, etc.).
                Only explicitly fractional numbers become floats.
            </p>
            <pre><code>// Large integer ID (preserved as i64)
{ "id": 9007199254740993 }  â†’ Integer(9007199254740993)

// Fractional number (float)
{ "price": 19.99 }  â†’ Float(19.99)</code></pre>

            <h2 id="dry-run">Testing with Dry Run</h2>
            <p>
                Test your extraction rules against sample requests before deploying.
                The <code>tenuo extract</code> command simulates constraint extraction without authorization.
            </p>
            <pre><code>$ tenuo extract \
    --config gateway-config.yaml \
    --path "/api/v1/clusters/staging-web/scale" \
    --method POST \
    --request '{"spec":{"replicas":5},"metadata":{"estimatedCost":150}}'

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚ Tenuo Extraction Dry Run
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚ Config:  gateway-config.yaml
â”‚ Request: POST /api/v1/clusters/staging-web/scale
â”‚ Tool:    manage_infrastructure
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ“‹ Extraction Results:

   Field                Source     Path                      Required   Result
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   âœ“ cluster            path       cluster                   yes        "staging-web"
   âœ“ action             path       action                    yes        "scale"
   â—‹ namespace          query      namespace                 no         (default)
   âœ“ replicas           body       spec.replicas             no         5
   âœ“ cost               body       metadata.estimatedCost    no         150.00

âœ… All required fields extracted successfully.</code></pre>
            <p>
                Use <code>--verbose</code> for detailed debugging hints when extraction fails:
            </p>
            <pre><code>$ tenuo extract --config gateway.yaml --path "/api/..." --verbose</code></pre>

            <h3>Validate Configuration</h3>
            <pre><code>$ tenuo validate-config --config gateway-config.yaml

âœ… Configuration is valid.

Summary:
  Tools:  3
  Routes: 4

  Tool 'manage_infrastructure':
    Description: Kubernetes cluster management
    Constraints: 5
      - cluster [Path] cluster (required)
      - action [Path] action (required)
      ...</code></pre>

            <h2 id="mcp-integration">MCP (Model Context Protocol) Integration</h2>
            <p>
                Tenuo provides native support for the <a href="https://modelcontextprotocol.io">Model Context Protocol</a>,
                the standard protocol for AI agent tool calling. This makes Tenuo a perfect fit for securing
                AI agent workflows without custom middleware.
            </p>

            <h3>Architecture Flow</h3>
            <p>
                Tenuo sits between the MCP server and tool execution, providing cryptographic authorization:
            </p>
            <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  AI Agent       â”‚
â”‚  (Claude/GPT)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ MCP tool call
         â”‚ {tool: "filesystem_read", arguments: {...}}
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MCP Server     â”‚
â”‚  (Tool Handler) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ Extract + Authorize
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Tenuo          â”‚â”€â”€â”€â”€â”€â–¶â”‚  Authorizer      â”‚
â”‚  extract_constraints() â”‚  check()         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                        â”‚
         â”‚ Extracted values       â”‚ âœ“ Authorized
         â”‚                        â”‚   or âœ— Denied
         â–¼                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Tool Execution â”‚      â”‚  Response        â”‚
â”‚  (if authorized)â”‚      â”‚  (to agent)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

            <h3>Why MCP + Tenuo?</h3>
            <ul>
                <li><strong>Native AI Agent Support</strong>: MCP is the standard protocol for AI agent tool calling.
                    Tenuo's integration means you can secure AI agent workflows without custom middleware.</li>
                <li><strong>Tool-Centric Authorization</strong>: MCP tools map directly to Tenuo tool configurations.
                    No HTTP routing complexityâ€”just map tool names to constraints.</li>
                <li><strong>Cryptographic Provenance</strong>: Every tool call is authorized by a warrant chain that proves
                    who delegated the authority and what bounds apply. Perfect for multi-agent workflows where
                    an orchestrator delegates to specialized workers.</li>
            </ul>

            <h3>Configuration</h3>
            <p>
                MCP configuration is simpler than HTTP gateway configuration because it doesn't need route matching.
                You just map MCP tool names directly to Tenuo tool configurations:
            </p>
            <pre><code># mcp-config.yaml
version: "1"

settings:
  trusted_issuers:
    - "f32e74b5a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8"

tools:
  filesystem_read:
    description: "Read files from the filesystem"
    constraints:
      path:
        from: body
        path: "path"
        required: true
        description: "File path to read"
      
      max_size:
        from: body
        path: "maxSize"
        type: integer
        default: 1048576
        description: "Maximum file size in bytes"
      
      allowed_paths:
        from: body
        path: "allowedPaths"
        description: "List of allowed path prefixes"
  
  database_query:
    description: "Execute database queries"
    constraints:
      table:
        from: body
        path: "query.table"
        required: true
      
      operation:
        from: body
        path: "query.operation"
        required: true
        allowed_values: ["select", "insert", "update", "delete"]
      
      row_limit:
        from: body
        path: "query.limit"
        type: integer
        default: 100</code></pre>

            <h3>Usage</h3>
            <pre><code>use tenuo_core::{Authorizer, CompiledMcpConfig, McpConfig, PublicKey, wire};
use serde_json::json;
use std::collections::HashMap;

// Load and compile configuration
let config = McpConfig::from_file("mcp-config.yaml")?;
let compiled = CompiledMcpConfig::compile(config);

// Validate configuration (warns about incompatible extraction sources)
let warnings = compiled.validate();
for warning in warnings {
    eprintln!("Warning: {}", warning);
}

// Initialize authorizer with trusted Control Plane key
let control_plane_key_bytes: [u8; 32] = hex::decode("f32e74b5...")?.try_into().unwrap();
let control_plane_key = PublicKey::from_bytes(&control_plane_key_bytes)?;
let authorizer = Authorizer::new(control_plane_key);

// MCP tool call arrives from AI agent
let arguments = json!({
    "path": "/var/log/app.log",
    "maxSize": 1024,
    "allowedPaths": ["/var/log", "/tmp"]
});

// 1. Extract constraints from MCP arguments
let result = compiled.extract_constraints("filesystem_read", &arguments)?;
// result.constraints contains:
//   - "path": ConstraintValue::String("/var/log/app.log")
//   - "max_size": ConstraintValue::Integer(1024)
//   - "allowed_paths": ConstraintValue::List([...])

// 2. Decode warrant chain (from MCP request metadata/headers)
let warrant = wire::decode_base64(&warrant_chain_base64)?;

// 3. Authorize the action using extracted constraints
authorizer.check(
    &warrant,
    "filesystem_read",
    &result.constraints,
    pop_signature.as_ref()  // Optional PoP signature
)?;

// 4. If authorized, execute the tool
// execute_filesystem_read(arguments);
</code></pre>

            <h3>Extraction Source Compatibility</h3>
            <p>
                MCP tool calls only provide an <code>arguments</code> JSON object. Extraction rules should use:
            </p>
            <ul>
                <li><code>from: body</code> - Extract from the arguments object (recommended)</li>
                <li><code>from: literal</code> - Use a default/literal value</li>
            </ul>
            <p>
                Rules using <code>from: path</code>, <code>from: query</code>, or <code>from: header</code> will not work
                in MCP context and will be flagged by <code>validate()</code>.
            </p>
            <div class="tip">
                <p><strong>Tip:</strong> The <code>validate()</code> method checks your configuration and warns about
                incompatible extraction sources. Run it during development to catch configuration issues early.</p>
            </div>

            <h2 id="planes">Control vs Data Plane</h2>
            <p>
                Tenuo separates concerns into two planes that can run in different security contexts:
            </p>
            <table>
                <tr><th>Control Plane</th><th>Data Plane</th></tr>
                <tr><td>Issues root warrants</td><td>Verifies warrant chains</td></tr>
                <tr><td>Holds root private key</td><td>Only has root public key</td></tr>
                <tr><td>Manages policy</td><td>Enforces policy</td></tr>
                <tr><td>Single secure instance</td><td>Distributed (gateway/sidecar)</td></tr>
                <tr><td>Network accessible</td><td>100% offline verification</td></tr>
            </table>
            <pre><code>// Control Plane (secure environment)
let control_plane = ControlPlane::new(root_keypair);
let warrant = control_plane.issue_warrant("tool", &constraints, ttl)?;

// Data Plane (distributed, e.g., sidecar)
let authorizer = Authorizer::new(control_plane.public_key());
authorizer.authorize(&warrant, "tool", &args, signature, &[])?;</code></pre>
            <p>
                <a href="../architecture-infographic.html">View the architecture diagram â†’</a>
            </p>

            <h2 id="properties">Security Properties</h2>
            <table>
                <tr><th>Property</th><th>Description</th></tr>
                <tr><td>Offline verification</td><td>No network calls needed</td></tr>
                <tr><td>Monotonic attenuation</td><td>Capabilities only shrink</td></tr>
                <tr><td>Holder binding</td><td>Stolen tokens are useless</td></tr>
                <tr><td>Depth limits</td><td>Max 64 delegation levels</td></tr>
                <tr><td>Constraint depth</td><td>Max 16 nesting levels</td></tr>
                <tr><td>Payload size</td><td>Max 1MB per warrant</td></tr>
            </table>
        </main>
    </div>

    <script>
        // Toggle sections on click
        document.querySelectorAll('.sidebar-title').forEach(title => {
            title.addEventListener('click', () => {
                title.parentElement.classList.toggle('expanded');
            });
        });

        // Scroll spy: highlight active link and expand its section
        const links = document.querySelectorAll('.sidebar-link[href^="#"]');
        const sections = [...links].map(link => document.querySelector(link.getAttribute('href'))).filter(Boolean);

        function updateActiveLink() {
            let current = sections[0];
            const scrollPos = window.scrollY + 100;

            for (const section of sections) {
                if (section.offsetTop <= scrollPos) {
                    current = section;
                }
            }

            links.forEach(link => {
                const isActive = link.getAttribute('href') === '#' + current.id;
                link.classList.toggle('active', isActive);
                if (isActive) {
                    link.closest('.sidebar-section').classList.add('expanded');
                }
            });
        }

        window.addEventListener('scroll', updateActiveLink);
        updateActiveLink();
    </script>
</body>
</html>
