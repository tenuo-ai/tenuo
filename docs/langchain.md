---
title: LangChain Integration
description: Tool protection for LangChain agents
---

# Tenuo LangChain Integration

> **Status**: âœ… Implemented  
> **Location**: `tenuo-python/examples/`

ðŸ“Š **Visual guide**: See the [LangChain Infographic](./langchain-infographic.html) for where Tenuo fits in your agent stack.

## Overview

Tenuo integrates with LangChain using a **zero-intrusion** pattern:

1. Tools remain pure business logic - no security imports
2. Security is applied at composition time via decorators
3. Warrants are passed through context, not function arguments
4. Fail-closed: missing or invalid warrants block execution

> **Note**: LangChain integration uses `Warrant.issue()` directly. You don't need `configure()` unless you're using LangGraph's `@tenuo_node` or `root_task()`. See [LangGraph Integration](./langgraph) for the `configure()` pattern.

---

## Installation
```bash
pip install tenuo
```

---

## Quick Start
```python
from tenuo import SigningKey, Warrant, Constraints, Pattern, lockdown, set_warrant_context, set_signing_key_context

# 1. Define a protected tool
@lockdown(tool="read_file")
def read_file(file_path: str) -> str:
    """Pure business logic - no security code"""
    with open(file_path, 'r') as f:
        return f.read()

# 2. Create keypair and warrant
keypair = SigningKey.generate()
warrant = Warrant.issue(
    capabilities=Constraints.for_tool("read_file", {"file_path": Pattern("/tmp/*")}),
    keypair=keypair,
    holder=keypair.public_key,
    ttl_seconds=3600
)

# 3. Execute with warrant context
with set_warrant_context(warrant), set_signing_key_context(keypair):
    content = read_file("/tmp/test.txt")  # âœ… Authorized
    content = read_file("/etc/passwd")    # âŒ Blocked by constraint
```

---

## Connecting to CLI-Generated Keys

Use keys generated by `tenuo keygen`:
```python
from tenuo import SigningKey

# 1. Generate keys using CLI
# $ tenuo keygen --out agent.key

# 2. Load keys (PEM format recommended)
with open("agent.key", "r") as f:
    keypair = SigningKey.from_pem(f.read())

# Or load raw bytes
# with open("agent.key", "rb") as f:
#     secret_bytes = f.read()
# keypair = SigningKey.from_bytes(secret_bytes)
```

Warrants issued by the CLI can be loaded:
```python
from tenuo import Warrant

# Load base64 warrant from CLI output
warrant = Warrant.from_base64(cli_warrant_string)
```

---

## The `@lockdown` Decorator

```python
@lockdown(tool="read_file")
def read_file(file_path: str, max_size: int = 1000) -> str:
    with open(file_path) as f:
        return f.read()[:max_size]
```

**Parameters:**

| Parameter | Description |
|-----------|-------------|
| `tool` | Tool name to check against warrant (required) |
| `extract_args` | Optional function to extract args. If omitted, uses automatic extraction (recommended). |
| `mapping` | Optional dict to rename parameters: `{"param_name": "constraint_name"}` |

**Behavior:**

1. Retrieves current warrant from context
2. **Extracts arguments** (automatic via `inspect.signature()` or custom via `extract_args`)
3. **Includes default values** (security: prevents bypass via omission)
4. Verifies tool is in warrant's allowed tools
5. Verifies extracted args satisfy warrant constraints
6. Generates PoP signature using context keypair
7. Executes function if authorized, raises `AuthorizationError` if not

### Automatic Extraction (Recommended)

When no `extract_args` is provided, Tenuo automatically extracts **all** parameters including defaults:

```python
@lockdown(tool="transfer")
def transfer(from_account: str, to_account: str, amount: float, memo: str = ""):
    ...

# Called as: transfer("acct1", "acct2", 100.0)
# Extracted: {from_account: "acct1", to_account: "acct2", amount: 100.0, memo: ""}
#                                                                          â†‘ default included
```

âœ… **Security:** Defaults are ALWAYS included (prevents bypass via omission).

### Custom Extraction

For parameter renaming or complex logic:

```python
@lockdown(
    tool="read_file",
    extract_args=lambda file_path, **kwargs: {"path": file_path}  # Rename to match constraint
)
def read_file(file_path: str) -> str:
    ...
```

âš ï¸ **Warning:** If you provide `extract_args`, YOU are responsible for extracting ALL security-relevant parameters.

### Parameter Mapping (Simpler Alternative)

For simple renames, use `mapping` instead:

```python
@lockdown(
    tool="read_file",
    mapping={"file_path": "path"}  # Rename after automatic extraction
)
def read_file(file_path: str, max_size: int = 1000):
    ...
# Extracted: {path: "...", max_size: 1000}
```

See [Argument Extraction](./argument-extraction) for comprehensive documentation and security considerations.

---

## Protecting Third-Party Tools

For tools you don't own (e.g., from `langchain_community`), you cannot add decorators. Use `protect_tools` to wrap them at runtime.

```python
from tenuo.langchain import protect_tools
from langchain_community.tools import DuckDuckGoSearchRun

# 1. Instantiate original tools
search = DuckDuckGoSearchRun()
wiki = WikipediaQueryRun(...)

# 2. Wrap them with Tenuo protection
# This applies @lockdown(tool=tool.name) to each tool
protected_tools = protect_tools([search, wiki])

# 3. Use protected_tools in your agent
agent = create_openai_tools_agent(llm, protected_tools)
```

**How it works:**
- Iterates through the list of tools
- Creates a wrapper that enforces warrant authorization
- Preserves tool metadata (name, description, args schema)
- Returns a new list of secure tools

---

## Context Management

### `set_warrant_context`

Sets the active warrant and keypair for the current execution context.
```python
with set_warrant_context(warrant), set_signing_key_context(keypair):
    # All @lockdown calls use this warrant and keypair
    protected_function()
```

**Parameters:**

| Parameter | Description |
|-----------|-------------|
| `warrant` | Active warrant for authorization |

**Properties:**

- Thread-safe (uses `contextvars`)
- Async-safe
- Nestable (inner context shadows outer)

---

## LangChain Agent Example
```python
from langchain.tools import Tool
from langchain.agents import AgentExecutor, create_openai_tools_agent
from langchain_openai import ChatOpenAI
from tenuo import SigningKey, Warrant, Pattern, lockdown, set_warrant_context, set_signing_key_context

# Protected tools
@lockdown(tool="search")
def search(query: str) -> str:
    return f"Results for: {query}"

@lockdown(tool="read_file", extract_args=lambda path, **kw: {"file_path": path})
def read_file(path: str) -> str:
    with open(path) as f:
        return f.read()

# Warrant setup
keypair = SigningKey.generate()
warrant = Warrant.issue(
    capabilities=Constraints.for_tools(
        ["search", "read_file"],
        {"file_path": Pattern("/tmp/*")}
    ),
    keypair=keypair,
    holder=keypair.public_key,
    ttl_seconds=3600
)

# LangChain setup
tools = [
    Tool(name="search", func=search, description="Search the web"),
    Tool(name="read_file", func=read_file, description="Read a file"),
]
llm = ChatOpenAI(model="gpt-4")
agent = create_openai_tools_agent(llm, tools)
executor = AgentExecutor(agent=agent, tools=tools)

# Run with protection
with set_warrant_context(warrant), set_signing_key_context(keypair):
    response = executor.invoke({"input": "Search for Q3 results"})
```

---

## Error Handling & Troubleshooting

When authorization fails, Tenuo raises `AuthorizationError` with a descriptive message:

```python
from tenuo import AuthorizationError

try:
    with set_warrant_context(warrant), set_signing_key_context(keypair):
        read_file("/etc/passwd")
except AuthorizationError as e:
    print(f"Authorization failed: {e}")
```

### Common Error Messages

| Error | Cause | Fix |
|-------|-------|-----|
| `Tool 'read_file' not authorized` | Tool not in warrant's tools list | Add tool to warrant, or use a warrant with the tool |
| `Constraint 'path' failed: warrant allows '/data/*', got '/etc/passwd'` | Argument violates constraint | Request file within allowed path, or attenuate warrant with broader constraint |
| `No warrant in context` | Missing `set_warrant_context()` | Wrap call in context manager |
| `No keypair in context` | Missing `set_signing_key_context()` | Wrap call in context manager |
| `Warrant expired` | TTL exceeded | Request fresh warrant |
| `PoP signature invalid` | Wrong keypair for warrant | Ensure keypair matches warrant's `authorized_holder` |

### Debugging Tips

```python
# Inspect warrant before use
print(f"Tools: {warrant.tools}")
print(f"Constraints: {warrant.constraints}")
print(f"Expires: {warrant.expires_at}")
print(f"Holder: {warrant.authorized_holder}")

# Verify keypair matches
assert warrant.authorized_holder == keypair.public_key, "SigningKey mismatch!"
```

---

## Constraints

Constraints restrict tool arguments. They mirror CLI constraint types:

| Type | Python | CLI Equivalent |
|------|--------|----------------|
| Exact | `Exact("/etc/hosts")` | `path=exact:/etc/hosts` |
| Pattern | `Pattern("/tmp/*")` | `path=pattern:/tmp/*` |
| Regex | `Regex(r"^prod-.*")` | `name=regex:^prod-.*` |
| Range | `Range(min=0.8, max=1.0)` | `confidence=range:0.8..1.0` |
| OneOf | `OneOf(["active", "pending"])` | `status=oneof:active,pending` |

---

## Examples

- **Simple**: `tenuo-python/examples/langchain_simple.py` - Basic integration
- **Advanced**: `tenuo-python/examples/langchain_integration.py` - With callbacks

---

## Limitations

- **Manual wrapping**: You must apply `@lockdown` to each tool
- **Manual attenuation**: Delegation requires explicit warrant creation
- **Single warrant**: Context holds one warrant at a time

For automatic attenuation in multi-agent graphs, see [LangGraph Integration](./langgraph).

---

## See Also

- [MCP Integration](./mcp) â€” Secure your AI agent tools with MCP
- [Argument Extraction](./argument-extraction) - How extraction works and security considerations
- [Python API Reference](./api-reference) - Full `@lockdown` documentation
- [CLI Reference](./cli) - Command-line tools
- [LangGraph Integration](./langgraph) - Multi-agent graph scoping
- [Protocol](./protocol) - Cryptographic protocol details
