# Tenuo LangChain Integration

> **Status**: ✅ Implemented  
> **Location**: `tenuo-python/examples/`

## Overview

Tenuo integrates with LangChain using a **zero-intrusion** pattern:

1. Tools remain pure business logic - no security imports
2. Security is applied at composition time via decorators
3. Warrants are passed through context, not function arguments
4. Fail-closed: missing or invalid warrants block execution

---

## Installation
```bash
pip install tenuo
```

---

## Quick Start
```python
from tenuo import Keypair, Warrant, Pattern, lockdown, set_warrant_context, set_keypair_context

# 1. Define a protected tool
@lockdown(tool="read_file")
def read_file(file_path: str) -> str:
    """Pure business logic - no security code"""
    with open(file_path, 'r') as f:
        return f.read()

# 2. Create keypair and warrant
keypair = Keypair.generate()
warrant = Warrant.issue(
    tools="read_file",
    keypair=keypair,
    holder=keypair.public_key,
    constraints={"file_path": Pattern("/tmp/*")},
    ttl_seconds=3600
)

# 3. Execute with warrant context
with set_warrant_context(warrant), set_keypair_context(keypair):
    content = read_file("/tmp/test.txt")  # ✅ Authorized
    content = read_file("/etc/passwd")    # ❌ Blocked by constraint
```

---

## Connecting to CLI-Generated Keys

Use keys generated by `tenuo keygen`:
```python
from tenuo import Keypair

# 1. Generate keys using CLI
# $ tenuo keygen --out agent.key

# 2. Load keys (PEM format recommended)
with open("agent.key", "r") as f:
    keypair = Keypair.from_pem(f.read())

# Or load raw bytes
# with open("agent.key", "rb") as f:
#     secret_bytes = f.read()
# keypair = Keypair.from_bytes(secret_bytes)
```

Warrants issued by the CLI can be loaded:
```python
from tenuo import Warrant

# Load base64 warrant from CLI output
warrant = Warrant.from_base64(cli_warrant_string)
```

---

## The `@lockdown` Decorator
```python
@lockdown(
    tool="read_file",
    extract_args=lambda file_path, **kwargs: {"file_path": file_path}
)
def read_file(file_path: str) -> str:
    ...
```

**Parameters:**

| Parameter | Description |
|-----------|-------------|
| `tool` | Tool name to check against warrant (required) |
| `extract_args` | Function to extract constraint-relevant args (optional) |

**Behavior:**

1. Retrieves current warrant from context
2. Verifies tool is in warrant's allowed tools
3. Verifies extracted args satisfy warrant constraints
4. Generates PoP signature using context keypair
5. Executes function if authorized, raises `AuthorizationError` if not

5. Executes function if authorized, raises `AuthorizationError` if not

---

## Protecting Third-Party Tools

For tools you don't own (e.g., from `langchain_community`), you cannot add decorators. Use `protect_tools` to wrap them at runtime.

```python
from tenuo.langchain import protect_tools
from langchain_community.tools import DuckDuckGoSearchRun

# 1. Instantiate original tools
search = DuckDuckGoSearchRun()
wiki = WikipediaQueryRun(...)

# 2. Wrap them with Tenuo protection
# This applies @lockdown(tool=tool.name) to each tool
protected_tools = protect_tools([search, wiki])

# 3. Use protected_tools in your agent
agent = create_openai_tools_agent(llm, protected_tools)
```

**How it works:**
- Iterates through the list of tools
- Creates a wrapper that enforces warrant authorization
- Preserves tool metadata (name, description, args schema)
- Returns a new list of secure tools

---

## Context Management

### `set_warrant_context`

Sets the active warrant and keypair for the current execution context.
```python
with set_warrant_context(warrant), set_keypair_context(keypair):
    # All @lockdown calls use this warrant and keypair
    protected_function()
```

**Parameters:**

| Parameter | Description |
|-----------|-------------|
| `warrant` | Active warrant for authorization |

**Properties:**

- Thread-safe (uses `contextvars`)
- Async-safe
- Nestable (inner context shadows outer)

---

## LangChain Agent Example
```python
from langchain.tools import Tool
from langchain.agents import AgentExecutor, create_openai_tools_agent
from langchain_openai import ChatOpenAI
from tenuo import Keypair, Warrant, Pattern, lockdown, set_warrant_context, set_keypair_context

# Protected tools
@lockdown(tool="search")
def search(query: str) -> str:
    return f"Results for: {query}"

@lockdown(tool="read_file", extract_args=lambda path, **kw: {"file_path": path})
def read_file(path: str) -> str:
    with open(path) as f:
        return f.read()

# Warrant setup
keypair = Keypair.generate()
warrant = Warrant.issue(
    tools="read_file",
    keypair=keypair,
    holder=keypair.public_key,
    constraints={"file_path": Pattern("/tmp/*")},
    ttl_seconds=3600
)

# LangChain setup
tools = [
    Tool(name="search", func=search, description="Search the web"),
    Tool(name="read_file", func=read_file, description="Read a file"),
]
llm = ChatOpenAI(model="gpt-4")
agent = create_openai_tools_agent(llm, tools)
executor = AgentExecutor(agent=agent, tools=tools)

# Run with protection
with set_warrant_context(warrant), set_keypair_context(keypair):
    response = executor.invoke({"input": "Search for Q3 results"})
```

---

## Error Handling
```python
from tenuo import AuthorizationError

try:
    with set_warrant_context(warrant), set_keypair_context(keypair):
        read_file("/etc/passwd")
except AuthorizationError as e:
    print(f"Authorization failed: {e}")
```

---

## Constraints

Constraints restrict tool arguments. They mirror CLI constraint types:

| Type | Python | CLI Equivalent |
|------|--------|----------------|
| Exact | `Exact("/etc/hosts")` | `path=exact:/etc/hosts` |
| Pattern | `Pattern("/tmp/*")` | `path=pattern:/tmp/*` |
| Regex | `Regex(r"^prod-.*")` | `name=regex:^prod-.*` |
| Range | `Range(min=0.8, max=1.0)` | `confidence=range:0.8..1.0` |
| OneOf | `OneOf(["active", "pending"])` | `status=oneof:active,pending` |

---

## Examples

- **Simple**: `tenuo-python/examples/langchain_simple.py` - Basic integration
- **Advanced**: `tenuo-python/examples/langchain_integration.py` - With callbacks

---

## Limitations

- **Manual wrapping**: You must apply `@lockdown` to each tool
- **Manual attenuation**: Delegation requires explicit warrant creation
- **Single warrant**: Context holds one warrant at a time

For automatic attenuation in multi-agent graphs, see [LangGraph Integration](./langgraph.md).

---

## See Also

- [CLI Reference](./cli-spec.md)
- [Python API Reference](./api-reference.md)
- [LangGraph Integration](./langgraph.md)
- [Protocol](./protocol.md)
